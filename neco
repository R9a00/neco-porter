#!/usr/bin/env node
// Neco Porter - ã‚·ãƒ³ãƒ—ãƒ«çµ±ä¸€ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

import { spawn } from 'child_process';
import { reserve, release, list } from './lib/necoport-v2.js';
import { launcher } from './src/launcher.js';
import fs from 'fs/promises';
import path from 'path';

const args = process.argv.slice(2);

// ã‚³ãƒãƒ³ãƒ‰ãªã—ã®å ´åˆã¯ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ãƒ¢ãƒ¼ãƒ‰
if (args.length === 0) {
  showInteractiveMenu();
  process.exit(0);
}

// ã‚¹ãƒãƒ¼ãƒˆã‚³ãƒãƒ³ãƒ‰è§£æ
async function smartRun() {
  const input = args.join(' ');
  
  // ç‰¹æ®Šã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®è§£æ
  let ports = {};
  let env = {};
  let commandArgs = [...args];
  
  // --ports ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®è§£æ
  const portsIndex = args.indexOf('--ports');
  if (portsIndex !== -1 && portsIndex < args.length - 1) {
    const portsSpec = args[portsIndex + 1];
    const portsList = portsSpec.split(',');
    
    portsList.forEach((spec, index) => {
      if (spec.includes(':')) {
        const [name, hint] = spec.split(':');
        ports[name] = { hint: parseInt(hint) };
      } else {
        ports[index === 0 ? 'main' : `port${index}`] = { hint: parseInt(spec) || 0 };
      }
    });
    
    // ã‚³ãƒãƒ³ãƒ‰ã‹ã‚‰ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã‚’å‰Šé™¤
    commandArgs.splice(portsIndex, 2);
  }
  
  // --env ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®è§£æ
  const envIndex = args.indexOf('--env');
  if (envIndex !== -1 && envIndex < args.length - 1) {
    const envSpec = args[envIndex + 1];
    envSpec.split(',').forEach(pair => {
      const [key, value] = pair.split('=');
      if (key && value) env[key] = value;
    });
    commandArgs.splice(envIndex, 2);
  }
  
  // ãƒ‘ã‚¿ãƒ¼ãƒ³1: "neco myapp" - è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰èµ·å‹•
  if (commandArgs.length === 1 && !commandArgs[0].includes('.')) {
    const hasConfig = await checkConfig();
    if (hasConfig) {
      console.log(`ğŸ± Starting ${commandArgs[0]} from config...`);
      await launcher.runFromConfig(commandArgs[0]);
      return;
    }
  }
  
  // ãƒ‘ã‚¿ãƒ¼ãƒ³2: "neco python app.py" - ç›´æ¥å®Ÿè¡Œ
  if (isExecutableCommand(commandArgs[0])) {
    const name = generateServiceName();
    console.log(`ğŸ± Running command with port management...`);
    
    const options = {
      command: commandArgs.join(' '),
      cwd: process.cwd()
    };
    
    // ã‚ªãƒ—ã‚·ãƒ§ãƒ³ãŒã‚ã‚Œã°è¿½åŠ 
    if (Object.keys(ports).length > 0) options.ports = ports;
    if (Object.keys(env).length > 0) options.env = env;
    
    await launcher.startService(name, options);
    return;
  }
  
  // ãƒ‘ã‚¿ãƒ¼ãƒ³3: "neco ." ã¾ãŸã¯ "neco start" - è‡ªå‹•æ¤œå‡ºã—ã¦èµ·å‹•
  if (input === '.' || input === 'start') {
    await autoStart();
    return;
  }
  
  // ãƒ‘ã‚¿ãƒ¼ãƒ³4: "neco stop" - å…¨åœæ­¢
  if (args[0] === 'stop') {
    await launcher.stopAll();
    console.log('âœ… All services stopped');
    return;
  }
  
  // ãƒ‘ã‚¿ãƒ¼ãƒ³5: "neco status" ã¾ãŸã¯ "neco ls" - çŠ¶æ…‹è¡¨ç¤º
  if (args[0] === 'status' || args[0] === 'ls') {
    await showStatus();
    return;
  }
  
  // ãƒ‘ã‚¿ãƒ¼ãƒ³6: ãƒ˜ãƒ«ãƒ—
  if (input === 'help' || input === '--help' || input === '-h') {
    showHelp();
    return;
  }
  
  // ä¸æ˜ãªã‚³ãƒãƒ³ãƒ‰
  console.log(`â“ Unknown command: ${input}`);
  console.log('Try: neco help');
}

// è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®å­˜åœ¨ç¢ºèª
async function checkConfig() {
  try {
    await fs.access('.necoport.yaml');
    return true;
  } catch {
    return false;
  }
}

// å®Ÿè¡Œå¯èƒ½ãªã‚³ãƒãƒ³ãƒ‰ã‹ãƒã‚§ãƒƒã‚¯
function isExecutableCommand(cmd) {
  const executables = [
    'node', 'npm', 'yarn', 'npx', 'pnpm',
    'python', 'python3', 'pip', 'pipenv', 'poetry',
    'ruby', 'bundle', 'rails',
    'go', 'cargo', 'java', 'gradle', 'mvn',
    'php', 'composer', 'dotnet',
    'sh', 'bash', 'zsh'
  ];
  
  return executables.includes(cmd) || 
         cmd.endsWith('.js') || 
         cmd.endsWith('.py') || 
         cmd.endsWith('.rb') ||
         cmd.endsWith('.sh') ||
         cmd.startsWith('./') ||
         cmd.startsWith('../');
}

// ã‚µãƒ¼ãƒ“ã‚¹åã®è‡ªå‹•ç”Ÿæˆ
function generateServiceName() {
  const cwd = process.cwd();
  const projectName = path.basename(cwd);
  const timestamp = Date.now().toString(36).slice(-4);
  return `${projectName}-${timestamp}`;
}

// Procfile ãƒ‘ãƒ¼ã‚µãƒ¼
async function parseProcfile(filename) {
  try {
    const content = await fs.readFile(filename, 'utf8');
    const lines = content.split('\n').filter(line => line.trim() && !line.startsWith('#'));
    const suggestions = [];
    
    for (const line of lines) {
      const [name, cmd] = line.split(':').map(s => s.trim());
      if (name && cmd) {
        suggestions.push({
          cmd,
          name: `procfile-${name}`,
          description: `Procfile: ${name}`,
          priority: 100
        });
      }
    }
    return suggestions;
  } catch {
    return [];
  }
}

// Makefile ãƒ‘ãƒ¼ã‚µãƒ¼
async function parseMakefile(filename) {
  try {
    const content = await fs.readFile(filename, 'utf8');
    const suggestions = [];
    
    // ã‚ˆãã‚ã‚‹ã‚¿ãƒ¼ã‚²ãƒƒãƒˆå
    const serverTargets = ['run', 'server', 'serve', 'start', 'dev', 'develop'];
    const lines = content.split('\n');
    
    for (const target of serverTargets) {
      if (lines.some(line => line.startsWith(`${target}:`))) {
        suggestions.push({
          cmd: `make ${target}`,
          name: `make-${target}`,
          description: `Makefile: ${target} target`,
          priority: 90
        });
      }
    }
    return suggestions;
  } catch {
    return [];
  }
}

// package.json è§£æ
async function analyzePackageJson(suggestions) {
  try {
    const packageJson = JSON.parse(await fs.readFile('package.json', 'utf8'));
    const scripts = packageJson.scripts || {};
    
    // main/start ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚‚ãƒã‚§ãƒƒã‚¯
    if (packageJson.main && !scripts.start) {
      suggestions.push({
        cmd: `node ${packageJson.main}`,
        name: 'node-main',
        description: `package.json main: ${packageJson.main}`,
        priority: 65
      });
    }
    
    // scripts ã®è§£æ
    const priorityScripts = [
      { name: 'dev', desc: 'Development server', priority: 85 },
      { name: 'start', desc: 'Start script', priority: 84 },
      { name: 'serve', desc: 'Serve', priority: 83 },
      { name: 'server', desc: 'Server', priority: 82 },
      { name: 'develop', desc: 'Development', priority: 81 }
    ];
    
    for (const { name, desc, priority } of priorityScripts) {
      if (scripts[name]) {
        suggestions.push({
          cmd: `npm run ${name}`,
          name: `npm-${name}`,
          description: `${desc} (${scripts[name].substring(0, 30)}...)`,
          priority
        });
      }
    }
  } catch {}
}

// ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåˆ†æ
async function analyzeProject() {
  const suggestions = [];
  const files = await fs.readdir('.');
  
  // ã‚ˆãã‚ã‚‹ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆã‚’å„ªå…ˆé †ä½ä»˜ãã§æ¤œç´¢
  const commonEntryPoints = [
    // è¨­å®šãƒ»èµ·å‹•ãƒ•ã‚¡ã‚¤ãƒ«
    { file: 'Procfile', parser: parseProcfile, priority: 100 },
    { file: 'docker-compose.yml', cmd: 'docker-compose up', priority: 95 },
    { file: 'docker-compose.yaml', cmd: 'docker-compose up', priority: 95 },
    { file: 'Makefile', parser: parseMakefile, priority: 90 },
    
    // Python
    { file: 'platform_manager.py', cmd: 'python3 platform_manager.py', priority: 85 },
    { file: 'manage.py', cmd: 'python manage.py runserver', priority: 80 },
    { file: 'app.py', cmd: 'python3 app.py', priority: 75 },
    { file: 'main.py', cmd: 'python3 main.py', priority: 74 },
    { file: 'server.py', cmd: 'python3 server.py', priority: 73 },
    { file: 'run.py', cmd: 'python3 run.py', priority: 72 },
    { file: '__main__.py', cmd: 'python3 .', priority: 71 },
    
    // Node.js
    { file: 'server.js', cmd: 'node server.js', priority: 70 },
    { file: 'index.js', cmd: 'node index.js', priority: 69 },
    { file: 'app.js', cmd: 'node app.js', priority: 68 },
    
    // Ruby
    { file: 'config.ru', cmd: 'bundle exec rackup', priority: 70 },
    { file: 'Rakefile', cmd: 'bundle exec rake server', priority: 65 },
    
    // Go
    { file: 'main.go', cmd: 'go run main.go', priority: 70 },
    
    // Java
    { file: 'pom.xml', cmd: 'mvn spring-boot:run', priority: 60 },
    { file: 'build.gradle', cmd: 'gradle bootRun', priority: 60 },
  ];
  
  // ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆã®æ¤œå‡º
  for (const entry of commonEntryPoints) {
    if (files.includes(entry.file)) {
      if (entry.parser) {
        // ãƒ‘ãƒ¼ã‚µãƒ¼ãŒã‚ã‚‹å ´åˆã¯å†…å®¹ã‚’è§£æ
        const parsed = await entry.parser(entry.file);
        if (parsed) suggestions.push(...parsed);
      } else if (entry.cmd) {
        suggestions.push({
          cmd: entry.cmd,
          name: path.basename(process.cwd()),
          description: `Auto-detected: ${entry.file}`,
          priority: entry.priority
        });
      }
    }
  }
  
  // package.json ã®è§£æï¼ˆç‰¹åˆ¥æ‰±ã„ï¼‰
  if (files.includes('package.json')) {
    await analyzePackageJson(suggestions);
  }
  
  // Python ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ - æ—¢ã«ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆã§æ¤œå‡ºæ¸ˆã¿ãªã®ã§ã“ã“ã§ã¯è¿½åŠ å‡¦ç†ãªã—
  
  // ãã®ä»–ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚¿ã‚¤ãƒ—ã¯æ—¢ã«commonEntryPointsã§å‡¦ç†æ¸ˆã¿
  
  // ã‚½ãƒ¼ãƒˆï¼ˆå„ªå…ˆåº¦é †ï¼‰
  return suggestions.sort((a, b) => b.priority - a.priority);
}

// è‡ªå‹•èµ·å‹•
async function autoStart() {
  console.log('ğŸ” Analyzing project...\n');
  
  // è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ãŒã‚ã‚‹å ´åˆ
  const hasConfig = await checkConfig();
  if (hasConfig) {
    console.log('ğŸ“‹ Found .necoport.yaml');
    const config = await launcher.loadConfig();
    const services = Object.keys(config.services || {});
    
    if (services.length === 1) {
      console.log(`ğŸš€ Starting ${services[0]}...`);
      await launcher.runFromConfig(services[0]);
    } else if (services.length > 1) {
      console.log('Multiple services found. Choose one:\n');
      services.forEach((s, i) => {
        console.log(`  ${i + 1}. neco ${s}`);
      });
      console.log(`  ${services.length + 1}. neco start    (run all)`);
      console.log('\nOr edit .necoport.yaml to customize.');
    }
    return;
  }
  
  // ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆåˆ†æ
  const suggestions = await analyzeProject();
  
  if (suggestions.length === 0) {
    console.log('âŒ Could not determine how to start this project.\n');
    console.log('Try one of these:');
    console.log('  1. Create .necoport.yaml configuration file');
    console.log('  2. Run a specific command: neco <your-command>');
    console.log('\nExample commands:');
    console.log('  neco python app.py');
    console.log('  neco npm run dev');
    console.log('  neco node server.js');
    return;
  }
  
  // ææ¡ˆã‚’è¡¨ç¤º
  console.log('ğŸ“‹ Found these options:\n');
  suggestions.forEach((s, i) => {
    console.log(`  ${i + 1}. ${s.cmd}`);
    console.log(`     ${s.description}`);
    console.log();
  });
  
  if (suggestions.length === 1) {
    console.log(`ğŸš€ Running: ${suggestions[0].cmd}\n`);
    await launcher.startService(suggestions[0].name, {
      command: suggestions[0].cmd,
      cwd: process.cwd()
    });
  } else {
    console.log('ğŸ’¡ Run with:');
    console.log(`   neco ${suggestions[0].cmd}`);
    console.log('\nOr create .necoport.yaml for custom configuration.');
  }
}

// ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤º
async function showStatus() {
  // å®Ÿè¡Œä¸­ã®ã‚µãƒ¼ãƒ“ã‚¹
  const services = launcher.listServices();
  if (services.length > 0) {
    console.log('ğŸ± Running services:\n');
    services.forEach(service => {
      console.log(`  ${service.name}`);
      console.log(`    PID: ${service.pid}`);
      console.log(`    Ports: ${Object.entries(service.ports).map(([k,v]) => `${k}:${v}`).join(', ')}`);
      console.log(`    Uptime: ${formatUptime(service.uptime)}`);
      console.log();
    });
  }
  
  // äºˆç´„æ¸ˆã¿ãƒãƒ¼ãƒˆ
  const ports = await list();
  if (ports.length > 0) {
    console.log('ğŸ“¦ Reserved ports:\n');
    ports.forEach(p => {
      console.log(`  ${p.cat} ${p.name}: ${p.port}`);
    });
  }
  
  if (services.length === 0 && ports.length === 0) {
    console.log('No active services or ports');
  }
}

// ã‚¢ãƒƒãƒ—ã‚¿ã‚¤ãƒ ã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
function formatUptime(seconds) {
  if (seconds < 60) return `${seconds}s`;
  if (seconds < 3600) return `${Math.floor(seconds / 60)}m ${seconds % 60}s`;
  const hours = Math.floor(seconds / 3600);
  const mins = Math.floor((seconds % 3600) / 60);
  return `${hours}h ${mins}m`;
}

// ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ãƒ†ã‚£ãƒ–ãƒ¡ãƒ‹ãƒ¥ãƒ¼
function showInteractiveMenu() {
  console.log(`
ğŸ± Neco Porter - Smart Port Manager

Quick Start:
  neco .                    # Auto-detect and start
  neco python app.py        # Run Python app
  neco npm run dev          # Run npm script
  
With Config (.necoport.yaml):
  neco myapp                # Start service 'myapp'
  neco start                # Start all services
  
Management:
  neco status               # Show running services
  neco stop                 # Stop all services

Examples:
  neco python manage.py runserver
  neco node server.js
  neco rails server
  neco ./my-script.sh
  `);
}

// ãƒ˜ãƒ«ãƒ—è¡¨ç¤º
function showHelp() {
  console.log(`
ğŸ± Neco Porter - The simplest way to manage ports

USAGE:
  neco [command/service]    # Smart detection

PATTERNS:
  neco .                    # Auto-detect and run
  neco <service>            # Run from .necoport.yaml
  neco <command...>         # Run any command
  neco status               # Show status
  neco stop                 # Stop everything

SMART DETECTION:
  - Finds package.json â†’ runs npm scripts
  - Finds requirements.txt â†’ runs Python files
  - Finds .necoport.yaml â†’ uses configuration

NO MORE PORT CONFLICTS! ğŸ‰
  `);
}

// ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
process.on('unhandledRejection', (err) => {
  console.error('âŒ Error:', err.message);
  process.exit(1);
});

// ãƒ¡ã‚¤ãƒ³å®Ÿè¡Œ
smartRun().catch(err => {
  console.error('âŒ Error:', err.message);
  process.exit(1);
});